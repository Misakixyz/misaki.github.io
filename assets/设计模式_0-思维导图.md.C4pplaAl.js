import{_ as a,o as e,c as l,a7 as i}from"./chunks/framework.Pik4XaBc.js";const q=JSON.parse('{"title":"设计模式-思维导图","description":null,"frontmatter":{"title":"设计模式-思维导图","hidden":true,"description":null,"tags":"设计模式","comment":true,"date":"2024-01-12T00:00:00.000Z","outline":[2,3]},"headers":[],"relativePath":"设计模式/0-思维导图.md","filePath":"设计模式/0-思维导图.md","lastUpdated":1717661601000}'),r={name:"设计模式/0-思维导图.md"},t=i('<h1 id="设计模式" tabindex="-1">设计模式 <a class="header-anchor" href="#设计模式" aria-label="Permalink to &quot;设计模式&quot;">​</a></h1><h2 id="第一部分-基础知识" tabindex="-1">第一部分 基础知识 <a class="header-anchor" href="#第一部分-基础知识" aria-label="Permalink to &quot;第一部分 基础知识&quot;">​</a></h2><h3 id="_1-设计模式概述" tabindex="-1">1.设计模式概述 <a class="header-anchor" href="#_1-设计模式概述" aria-label="Permalink to &quot;1.设计模式概述&quot;">​</a></h3><h3 id="_2-uml类图与面向对象设计原则" tabindex="-1">2.UML类图与面向对象设计原则 <a class="header-anchor" href="#_2-uml类图与面向对象设计原则" aria-label="Permalink to &quot;2.UML类图与面向对象设计原则&quot;">​</a></h3><h2 id="第二部分-创建的艺术——创建模式" tabindex="-1">第二部分 创建的艺术——创建模式 <a class="header-anchor" href="#第二部分-创建的艺术——创建模式" aria-label="Permalink to &quot;第二部分 创建的艺术——创建模式&quot;">​</a></h2><h3 id="_3-确保对象的唯一性——单例模式" tabindex="-1">3.确保对象的唯一性——单例模式 <a class="header-anchor" href="#_3-确保对象的唯一性——单例模式" aria-label="Permalink to &quot;3.确保对象的唯一性——单例模式&quot;">​</a></h3><ul><li>特征 <ul><li>1.某个类只能有一个实例</li><li>2.它必须自行创建这个实例</li><li>3.它必须自行向整个系统提供这个实例</li></ul></li><li>懒汉式单例</li><li>饿汉式单例</li><li>主要优点 <ul><li>1.单例模式提供了对唯一实例的受控访问。</li><li>2.由于在系统内存中只存在一个对象，因此可以节约系统资源。</li><li>3.允许可变数目的实例</li></ul></li><li>主要缺点 <ul><li>1.由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>2.单例类的职责过重，在一定程度上违背了单一职责原则。因为单例类既提供了业务方法，又提供了创建对象的方法（工厂方法），将对象的创建和对象本身的功能耦合在一起。</li><li>3.现在很多面向对象语言（如Java、C＃）的运行环境都提供了自动垃圾回收技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失。</li></ul></li><li>适用场景 <ul><li>1.系统只需要一个实例对象。例如，系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>2.客户调用类的单个实例只允许使用一个公共访问点。除了该公共访问点，不能通过其他途径访问该实例。</li></ul></li></ul><h3 id="_4-集中式工厂的实现——简单工厂模式" tabindex="-1">4.集中式工厂的实现——简单工厂模式 <a class="header-anchor" href="#_4-集中式工厂的实现——简单工厂模式" aria-label="Permalink to &quot;4.集中式工厂的实现——简单工厂模式&quot;">​</a></h3><ul><li><h2 id="主要优点" tabindex="-1">主要优点 <a class="header-anchor" href="#主要优点" aria-label="Permalink to &quot;主要优点&quot;">​</a></h2></li><li>主要缺点</li><li>适用场景 <ul><li>1.工厂类负责创建的对象比较少。由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂</li><li>2.客户端只知道传入工厂类的参数，对于如何创建对象并不关心</li></ul></li></ul><h3 id="_5-多态工厂的实现——工厂方法" tabindex="-1">5.多态工厂的实现——工厂方法 <a class="header-anchor" href="#_5-多态工厂的实现——工厂方法" aria-label="Permalink to &quot;5.多态工厂的实现——工厂方法&quot;">​</a></h3><h3 id="_6-产品族的创建——抽象工厂模式" tabindex="-1">6.产品族的创建——抽象工厂模式 <a class="header-anchor" href="#_6-产品族的创建——抽象工厂模式" aria-label="Permalink to &quot;6.产品族的创建——抽象工厂模式&quot;">​</a></h3><h3 id="_7-对象的克隆——原型模式" tabindex="-1">7.对象的克隆——原型模式 <a class="header-anchor" href="#_7-对象的克隆——原型模式" aria-label="Permalink to &quot;7.对象的克隆——原型模式&quot;">​</a></h3><h3 id="_8-复杂对象的组装与创建——建造者模式" tabindex="-1">8.复杂对象的组装与创建——建造者模式 <a class="header-anchor" href="#_8-复杂对象的组装与创建——建造者模式" aria-label="Permalink to &quot;8.复杂对象的组装与创建——建造者模式&quot;">​</a></h3><h2 id="第三部分-组合的艺术——结构模式" tabindex="-1">第三部分 组合的艺术——结构模式 <a class="header-anchor" href="#第三部分-组合的艺术——结构模式" aria-label="Permalink to &quot;第三部分 组合的艺术——结构模式&quot;">​</a></h2><h3 id="_9-不兼容结构的协调——适配器模式" tabindex="-1">9.不兼容结构的协调——适配器模式 <a class="header-anchor" href="#_9-不兼容结构的协调——适配器模式" aria-label="Permalink to &quot;9.不兼容结构的协调——适配器模式&quot;">​</a></h3><h3 id="_10-处理多维度变化——桥接模式" tabindex="-1">10.处理多维度变化——桥接模式 <a class="header-anchor" href="#_10-处理多维度变化——桥接模式" aria-label="Permalink to &quot;10.处理多维度变化——桥接模式&quot;">​</a></h3><h3 id="_11-树形结构的处理——组合模式" tabindex="-1">11.树形结构的处理——组合模式 <a class="header-anchor" href="#_11-树形结构的处理——组合模式" aria-label="Permalink to &quot;11.树形结构的处理——组合模式&quot;">​</a></h3><h3 id="_12-扩展系统功能——装饰模式" tabindex="-1">12.扩展系统功能——装饰模式 <a class="header-anchor" href="#_12-扩展系统功能——装饰模式" aria-label="Permalink to &quot;12.扩展系统功能——装饰模式&quot;">​</a></h3><h3 id="_13-提供统一入口——外观模式" tabindex="-1">13.提供统一入口——外观模式 <a class="header-anchor" href="#_13-提供统一入口——外观模式" aria-label="Permalink to &quot;13.提供统一入口——外观模式&quot;">​</a></h3><h3 id="_14-实现对象的复用——享元模式" tabindex="-1">14.实现对象的复用——享元模式 <a class="header-anchor" href="#_14-实现对象的复用——享元模式" aria-label="Permalink to &quot;14.实现对象的复用——享元模式&quot;">​</a></h3><h3 id="_15-对象的间接访问——代理模式" tabindex="-1">15.对象的间接访问——代理模式 <a class="header-anchor" href="#_15-对象的间接访问——代理模式" aria-label="Permalink to &quot;15.对象的间接访问——代理模式&quot;">​</a></h3><h2 id="第四部分-交互的艺术——行为型模式" tabindex="-1">第四部分 交互的艺术——行为型模式 <a class="header-anchor" href="#第四部分-交互的艺术——行为型模式" aria-label="Permalink to &quot;第四部分 交互的艺术——行为型模式&quot;">​</a></h2><h3 id="_16-请求的链式处理——职责链模式" tabindex="-1">16.请求的链式处理——职责链模式 <a class="header-anchor" href="#_16-请求的链式处理——职责链模式" aria-label="Permalink to &quot;16.请求的链式处理——职责链模式&quot;">​</a></h3><h3 id="_17-请求发送者与接收者解耦——命令模式" tabindex="-1">17.请求发送者与接收者解耦——命令模式 <a class="header-anchor" href="#_17-请求发送者与接收者解耦——命令模式" aria-label="Permalink to &quot;17.请求发送者与接收者解耦——命令模式&quot;">​</a></h3><h3 id="_18-自定义语言的实现——解释器模式" tabindex="-1">18.自定义语言的实现——解释器模式 <a class="header-anchor" href="#_18-自定义语言的实现——解释器模式" aria-label="Permalink to &quot;18.自定义语言的实现——解释器模式&quot;">​</a></h3><h3 id="_19-遍历聚合对象中的元素——迭代器模式" tabindex="-1">19.遍历聚合对象中的元素——迭代器模式 <a class="header-anchor" href="#_19-遍历聚合对象中的元素——迭代器模式" aria-label="Permalink to &quot;19.遍历聚合对象中的元素——迭代器模式&quot;">​</a></h3><h3 id="_20-协调多个对象之间的交互——中介者模式" tabindex="-1">20.协调多个对象之间的交互——中介者模式 <a class="header-anchor" href="#_20-协调多个对象之间的交互——中介者模式" aria-label="Permalink to &quot;20.协调多个对象之间的交互——中介者模式&quot;">​</a></h3><h3 id="_21-撤销功能的实现——备忘录模式" tabindex="-1">21.撤销功能的实现——备忘录模式 <a class="header-anchor" href="#_21-撤销功能的实现——备忘录模式" aria-label="Permalink to &quot;21.撤销功能的实现——备忘录模式&quot;">​</a></h3><h3 id="_22-对象建的联动——观察者模式" tabindex="-1">22.对象建的联动——观察者模式 <a class="header-anchor" href="#_22-对象建的联动——观察者模式" aria-label="Permalink to &quot;22.对象建的联动——观察者模式&quot;">​</a></h3><h3 id="_23-对象状态及其转换——状态模式" tabindex="-1">23.对象状态及其转换——状态模式 <a class="header-anchor" href="#_23-对象状态及其转换——状态模式" aria-label="Permalink to &quot;23.对象状态及其转换——状态模式&quot;">​</a></h3><h3 id="_24-算法的封装与切换——策略模式" tabindex="-1">24.算法的封装与切换——策略模式 <a class="header-anchor" href="#_24-算法的封装与切换——策略模式" aria-label="Permalink to &quot;24.算法的封装与切换——策略模式&quot;">​</a></h3><h3 id="_25-定义算法的框架——模板方法模式" tabindex="-1">25.定义算法的框架——模板方法模式 <a class="header-anchor" href="#_25-定义算法的框架——模板方法模式" aria-label="Permalink to &quot;25.定义算法的框架——模板方法模式&quot;">​</a></h3><h3 id="_26-操作复杂对象结构——访问者模式" tabindex="-1">26.操作复杂对象结构——访问者模式 <a class="header-anchor" href="#_26-操作复杂对象结构——访问者模式" aria-label="Permalink to &quot;26.操作复杂对象结构——访问者模式&quot;">​</a></h3>',33),h=[t];function o(n,d,u,s,c,_){return e(),l("div",{"data-pagefind-body":!0},h)}const m=a(r,[["render",o]]);export{q as __pageData,m as default};
